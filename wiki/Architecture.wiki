The PAT application is an assemblage of different layers and different frameworks. The front-end is generated by GWT. The back-end is Spring. The connection point between those two is the org.pentaho.pat.rpc package. It defines all the interfaces that the servlets expose to the GUI.

The main skeletton of the application is as follows :

  * org.pentaho.pat : This is the main package.
    * org.pentaho.pat.client : Everything related to GUI.
    * org.pentaho.pat.rpc : This is the RPC interfaces for client-server communications.
    * org.pentaho.pat.server : This is the main package of everything related to server stuff.
      * org.pentaho.pat.server.data : This is the persistence classes.
      * org.pentaho.pat.server.services : This is the service layer of the server.
      * org.pentaho.pat.server.servlet : This is the web layer of the server. It contains all the servlets that implement the RPC interfaces.

= Project dependencies =

This project depends, among other things, on those other projects :

  * Spring framework.
  * Google web toolkit
  * Hibernate


= Servlet Layer =

The only layer that a client needs to be aware of is the RPC interfaces defined in org.pentaho.pat.rpc. Any GUI implementation MUST conform to it. Those interfaces are in turn implemented as web servlets. We could have implemented them with any other technology we needed.

The RPC implementations responsibilities are:

  * Expose the services to the external world.
  * Authenticate clients.
  * Allows a single user to work with more than one "window session" simult.
  * Prevent clients from spoofing a window session id using the specific implementation's authentications technologies.

By default, a set of GWT friendly servlets implement the RPC interfaces.

= Service layer =

At first sight, this might look like a duplication of the RPC implementations, but there is something fundamentally different done in this layer. 

First off, those classes are not bound to any particular technology other than Olap4j and Spring. It is completely abstracted from the communication channels that feed it. It is neither a servlet or a GWT module. It is a plain old Java object implementing a given service interface. This ensures that the whole business logic can be wrapped with whatever server communication technology.

The service layer is thus the core of PAT. PAT was meant to be this way so it keeps the overhead at a minimum and relays all query operations to the Olap4j model layer. This layer is the last invoked in a request.

= Persistence layer =

Pat stores some information about the users and groups. For instance, we can store saved connection parameters for later reuse. The persistence is done via Hibernate. There are no ORM mapping files involved, rather we use the Java Persistence API annotations with POJOs.

By default, the data is persisted in an in-memory HSQLDB instance. Although this is a simple and quite way of persisting data, it is strongly recommended to change this behavior in production deployments. It can be easily configured and PAT persistence layer leverages all Hibernate supported databases.

= Security =

The security is implemented with Spring Security. It intercepts any incoming web requests and authenticates if necessary. By default, we use the HTTP Basic authentication mechanism, but Spring Security can be easily configured to support single sign-on or LDAP authentication as well.